QUESTIONS
	 
LAST TIME:
 - Administrivia: Program 3 due date adjustment and time penalties
 - Recursion, linked lists, binary search

TODAY:
 - Administrivia
 - Bug fix/miscellaneous
 - Recursion, binary search, O(log n)             char a = '6';
						  int num = a-'0';
HOMEWORK: PC++P Ch 18, Ch 20 (pg 355-365)
           
   Program 3 due: 1PM MON Apr 3, 2000
	       	  UNDER 9 days 23 hours REMAINING	     
       	       	       	       	       	       	   Bignum a;
						   a = 3;   
       	       	       	       	       	       	   
       	       	       	       	       	       	   Bignum a = 3;
						   Bignum a(3);




ADMINISTRIVIA
	 
 - For Fri 3/24/00 (today), Ackley office hours end 4:30PM 

 - Second in-class quiz 2PM FRI APR 7 (two weeks from today)

















					

PROGRAM 3 FAQ

If you see this when testing at level 3:
					
    ...
	     COPY CTOR LINEARITY TEST

	       Average = 0 usec/elt  Standard deviation = 1.8749
    TestBignum.C:806 FAILED: COPY CTOR (0)
    ...
   
you should download a new copy of TestBignum.C.
   







	 

           

ADMINISTRIVIA
	 
Program 3: UNDER 9 days 23 hours REMAINING	 
	  	       	       	       	      vvv
     Due: 1PM MON Apr 3, 2000  NOTE THAT'S >>>1PM<<<
                                              ^^^

Free                 TIME PENALTIES FOR PROGRAM 3
Late           	     Last turned in BEFORE 1PM on:
DaysTHU3/30 FRI3/31 SAT4/1 SUN4/2  MON4/3 TUE4/4 WED4/5 LATER
+------------------------------------------------------------+
| 0 |  +3% |   0%  |   0% |   0%  |   0% | -33% | -66% |-100%|
+------------------------------------------------------------+
| 1 |  +3% |   0%  |   0% |   0%  |   0% |   0% | -33% |-100%|
+------------------------------------------------------------+
| 2 |  +3% |   0%  |   0% |   0%  |   0% |   0% |   0% |-100%|
+------------------------------------------------------------+
| 3 |  +3% |   0%  |   0% |   0%  |   0% |   0% |   0% |-100%|
+------------------------------------------------------------+

Reminder:
	 
  NO CREDIT FOR PROGRAM 3 AFTER CLASS STARTS ON WED APR 5, 2000.
           
BIGNUM STATUS SURVEY

`Clean frontier' (highest test level passed) is:
       	    T-13d  T-11d  T-9d
     level 9: 1      0 	      
     level 8: 0	     0	   
     level 7: 0	     0	   
     level 6: 0	     1	   1
     level 5: 0	     1	   1
     level 4: 1	     0	   2
     level 3: 0	     3	   4
     LEVEL 2: 6	     4	   8
     LEVEL 1: 0	     1	   5
     LEVEL 0: 5	     22	  11
Planning to	       	    
 drop CS251	       	    
     anyway : oo     oo	 <oo   
		     






BUG FIX / const methods / implementing friends 























BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f) {
    f.Backward(o);
    return o;
  }
private:
  char _c;
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl
  delete hd;
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f) {
    f.Backward(o); // foo2.C:9: no matching function for call to
    return o;	   // `Foo::Backward (ostream &) const'
  }
private:
  char _c;
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl
  delete hd;        // foo2.C:20: parse error before `delete'
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f) {
    f.Backward(o); // foo2.C:9: no matching function for call to
    return o;	   // `Foo::Backward (ostream &) const'
  }
private:
  char _c;
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;        
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>			     
class Foo {    	       	  		     
public:			  		     
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }	     	    /-(1) f is   
  void Backward(ostream & o) {              	    |  	  const	  
    if (_next) _next->Backward(o); o << _c;    }    v  	       
  friend ostream & operator<<(ostream&o,const Foo & f) {       
    f.Backward(o); // foo2.C:9: no matching function for call to
    return o;	   // `Foo::Backward (ostream &) const'	       
  }    	      
private:      
  char _c;    
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;        
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>			     
class Foo {    	       	    		     
public:			    		     
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }	     	    /-(1) f is   
  void Backward(ostream & o) {               	    |  	  const	  
    if (_next) _next->Backward(o); o << _c;    }    v  	       
  friend ostream & operator<<(ostream&o,const Foo & f) {       
    f.Backward(o); // foo2.C:9: no matching function for call to
    return o;\	   // `Foo::Backward (ostream &) const'	       
  }           \			 			       
private:       (2) We're trying to call Foo::Backward on f
  char _c;	   
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;        
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>			     /-(3) But 
class Foo {				     |	   Foo::Backward
public:					     | 	   isn't a const
  Foo(char ch,Foo* n) { _c = ch; _next = n; }| 	   method.     	
  ~Foo() { if (_next) delete _next; }	    /	    /-(1) f is   
  void Backward(ostream & o) {<------------/	    |  	  const	  
    if (_next) _next->Backward(o); o << _c;    }    v  	       
  friend ostream & operator<<(ostream&o,const Foo & f) {       
    f.Backward(o); // foo2.C:9: no matching function for call to
    return o;\	   // `Foo::Backward (ostream &) const'	       
  }           \			 			       
private:       (2) We're trying to call Foo::Backward on f
  char _c;
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;        
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>			     /-(3) But 
class Foo {				     |	   Foo::Backward
public:					     | 	   isn't a const
  Foo(char ch,Foo* n) { _c = ch; _next = n; }| 	   method.     	
  ~Foo() { if (_next) delete _next; }	    /	    /-(1) f is   
  void Backward(ostream & o) {<------------/	    |  	  const	  
    if (_next) _next->Backward(o); o << _c;    }    v  	       
  friend ostream & operator<<(ostream&o,const Foo & f) {       
    f.Backward(o); // foo2.C:9: no matching function for call to\
    return o;\	   // `Foo::Backward (ostream &) const'	       	/|
  }           \			 		       	       	 /
private:       (2) We're trying to call Foo::Backward on f     	/
  char _c;				     (4) So the compiler
  Foo * _next; 	       	       	       	       	 barfs 	       	 
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;        
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>			     /-(3) But 
class Foo {				     |	   Foo::Backward
public:					     | 	   isn't a const
  Foo(char ch,Foo* n) { _c = ch; _next = n; }| 	   method.     	
  ~Foo() { if (_next) delete _next; }	    /	    /-(1) f is   
 /void Backward(ostream & o) {<------------/	    |  	  const	  
/\  if (_next) _next->Backward(o); o << _c;    }    v  	       
| friend ostream & operator<<(ostream&o,const Foo & f) {       
|   f.Backward(o); // foo2.C:9: no matching function for call to\
\   return o;\	   // `Foo::Backward (ostream &) const'	       	/|
 ------------ \			 		       	       	 /
private:     \ (2) We're trying to call Foo::Backward on f     	/
  char _c;    \				     (4) So the compiler
  Foo * _next; (5) But Foo::Backward actually  	 barfs 	       	 
};		   never modifies *this anyway,
int main() {	   so what's the big deal?     
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;        
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>			     /-(3) But 
class Foo {				     |	   Foo::Backward
public:					     | 	   isn't a const
  Foo(char ch,Foo* n) { _c = ch; _next = n; }| 	   method.     	
  ~Foo() { if (_next) delete _next; }	    /	    /-(1) f is   
 /void Backward(ostream & o) {<------------/	    |  	  const	  
/\  if (_next) _next->Backward(o); o << _c;    }    v  	       
| friend ostream & operator<<(ostream&o,const Foo & f) {       
|   f.Backward(o); // foo2.C:9: no matching function for call to\
\   return o;\ 	   // `Foo::Backward (ostream &) const'	       	/|
 ------------ \			 		       	       	 /
private:     \ (2) We're trying to call Foo::Backward on f     	/
  char _c;    \				     (4) So the compiler
  Foo * _next; (5) But Foo::Backward actually  	 barfs 	       	 
};		   never modifies *this anyway,	      
int main() {	   so what's the big deal?   
  Foo * hd = NULL;	     		       	       	       	
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;	     		     
  delete hd;        	 (6) The deal is, WE have to tell the
  return 0;		     compiler explicitly if a method 
}			     is not going to modify *this.  If so,
			     it's called a 'const method'.     	  
BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f) {
    f.Backward(o); // foo2.C:9: no matching function for call to 
    return o;  	   // `Foo::Backward (ostream &) const'	       	
  }
private:
  char _c;
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const { 
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f) {
    f.Backward(o); 
    return o;  	   
  }
private:
  char _c;
  Foo * _next;
};
int main() {
  Foo * hd = NULL;
  hd = new Foo('A',hd);hd = new Foo('B',hd);hd = new Foo('C',hd);
  cout << *hd << endl;
  delete hd;
  return 0;
}

BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f) {
    f.Backward(o); 
    return o;  	   
  }
private:
  char _c;
  Foo * _next;
};








BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:					       
  char _c;					       
  Foo * _next;
};











BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
friend ostream & operator<<(ostream&o,const Foo & f) {
  f.Backward(o);
  return o;
}







BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
friend ostream & operator<<(ostream&o,const Foo & f) {  
  f.Backward(o);
  return o;
}

foo.C:13: can't initialize friend function `<<'
foo.C:13: friend declaration not in class definition
 etc



BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
ostream & Foo::operator<<(ostream&o,const Foo & f) {
  f.Backward(o);
  return o;
}







BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
ostream & Foo::operator<<(ostream&o,const Foo & f) {
  f.Backward(o);
  return o;
}

foo.C:13: `Foo::operator <<(ostream &, const Foo &)' must take e..
foo.C:13: no `class ostream & Foo::operator <<(class ostream &, ..




BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
Foo::ostream & operator<<(ostream&o,const Foo & f) {
  f.Backward(o);
  return o;
}







BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
Foo::ostream & operator<<(ostream&o,const Foo & f) {
  f.Backward(o);
  return o;
}

foo.C:13: syntax error before `&'





BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:       
  char _c;    
  Foo * _next;
};   	      
     	      










BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:\----\
  char _c;    \
  Foo * _next;|
};   	      |
       	      |	       	       	       	       	       	     
(1) Here, 'friend' says 'the following function can access   
    my private members (assuming that function can get access
    to an instance of my class).'	       		     
   					       		     






BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:\----\
  char _c;    \
  Foo * _next;|
};   	      |
     	      |
(1) Here, 'friend' says 'the following function can access
    my private members (assuming that function can get access 
    to an instance of my class).'	       		      
   					       		      
(2) 'friend' is NOT part of the function name, arguments, or  
    return type.  			       		      
					       		      



BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:\----\
  char _c;    \	       	       	       	       	       	
  Foo * _next;|						
};   	      |						
     	      |						
(1) Here, 'friend' says 'the following function can access
    my private members (assuming that function can get access
    to an instance of my class).'	       		     
   					       		     
(2) 'friend' is NOT part of the function name, arguments, or 
    return type.  			       		     
					       		     
(3) The function that's made a friend is NOT a member of the 
    class!  It has no 'this' pointer!  You cannot refer to   
    class data members implicitly.
BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:\----\
  char _c;    \
  Foo * _next;|
};   	      |
     	      |
(1) Here, 'friend' says 'the following function can access
    my private members (assuming that function can get access \ 
    to an instance of my class).'	       		      /|
   					       		       |
(2) 'friend' is NOT part of the function name, arguments, or   |
    return type.  			       		       |
					       		       |
(3) The function that's made a friend is NOT a member of the   |
    class!  It has no 'this' pointer!  You cannot refer to     /
    class data members implicitly.  (That's why we said)------/
BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};











BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
ostream & operator<<(ostream&o,const Foo & f) 










BUG FIX / const methods / implementing friends 
#include <iostream.h>
class Foo {
public:
  Foo(char ch,Foo* n) { _c = ch; _next = n; }
  ~Foo() { if (_next) delete _next; }
  void Backward(ostream & o) const {
    if (_next) _next->Backward(o); o << _c;    }
  friend ostream & operator<<(ostream&o,const Foo & f);
private:
  char _c;
  Foo * _next;
};
ostream & operator<<(ostream&o,const Foo & f) {
  f.Backward(o);
  return o;
}







RECURSION: BINARY SEARCH























RECURSION: BINARY SEARCH

Guess the number.
 Find some unknown number x in [0..1000000000]
 as quickly as possible, given a function
			      / -1 if n<x
 int Test(int n) that returns |	 0 if n==x
       			      \	 1 if n>x

int Guess1() {
  for (int i = 0;i<=1000000000;++i) if (Test(i)==0) return i;
  assert(0);  // "Can't happen"
}

Works?

Fast?   How many calls on 'Test(int)'?    What's 'n'?  O(n).







RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;              // find midpoint of range
  int val = Test(mid);		       // test it
  if (val<0) return GuessR(mid+1,hi);  // low, raise range bottom
  if (val>0) return GuessR(lo,mid-1);  // high, lower range top
  return mid;			       // just right
}
















RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               
     int mid = (hi-lo)/2+lo;                  
     int val = Test(mid);                     
     if (val<0) return GuessR(mid+1,hi);      
     if (val>0) return GuessR(lo,mid-1);      
     return mid;                              
   }                                          
   int Test(int guess) {                      
     if (guess<7) return -1;                  
     if (guess>7) return  1;                  
     return 0;                                
   }                                          
   int main() { return GuessR(0,10); }        
					      
					      
					      
					      
					      
					      
					      
					      
					      
					      
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |                 |
     int val = Test(mid);                     |                	|
     if (val<0) return GuessR(mid+1,hi);      |		       	|
     if (val>0) return GuessR(lo,mid-1);      |		       	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
>> int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
>> int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     |                	|
     if (val<0) return GuessR(mid+1,hi);      |		       	|
     if (val>0) return GuessR(lo,mid-1);      |		       	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
>>   int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5          	|
     if (val<0) return GuessR(mid+1,hi);      |		       	|
     if (val>0) return GuessR(lo,mid-1);      |		       	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5          	|
     if (val<0) return GuessR(mid+1,hi);      |Test guess=5    	|
     if (val>0) return GuessR(lo,mid-1);      |	return=-1      	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
>>   if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
>>   int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |                	|
     if (val>0) return GuessR(lo,mid-1);      |	               	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
>>   if (val<0) return GuessR(mid+1,hi);      |                	|
     if (val>0) return GuessR(lo,mid-1);      |	               	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
>> int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	               	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
>>   int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8          	|
     return mid;                              |		       	|
   }                                          |		       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8          	|
     return mid;                              |Test guess=8    	|
   }                                          |	return 1       	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
>>   if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
>>   if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |                	|
   }                                          |	               	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
>> int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	               	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
>>   int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6          	|
   int Test(int guess) {                      |		       	|
     if (guess<7) return -1;                  |		       	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6          	|
   int Test(int guess) {                      |Test guess=6    	|
>>   if (guess<7) return -1;                  |	return -1      	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
>>   int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |                	|
     if (guess<7) return -1;                  |	               	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
>>   if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |                	|
     if (guess<7) return -1;                  |	               	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
>> int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |GuessR lo=7,hi=7	|
     if (guess<7) return -1;                  |	               	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
>>   int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |GuessR lo=7,hi=7	|
     if (guess<7) return -1;                  |	mid=7          	|
     if (guess>7) return  1;                  |		       	|
     return 0;                                |		       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |GuessR lo=7,hi=7	|
     if (guess<7) return -1;                  |	mid=7          	|
     if (guess>7) return  1;                  |Test guess=7    	|
>>   return 0;                                |	return 0       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |GuessR lo=7,hi=7	|
     if (guess<7) return -1;                  |	mid=7          	|
     if (guess>7) return  1;                  |Test guess=7    	|
>>   return 0;                                |	return 0       	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
    					      |		       	|
  ((OK, we found it... Note that we're	      |		       	|
    currently four deep in calls to GuessR..))|		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
>>   int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |GuessR lo=7,hi=7	|
     if (guess<7) return -1;                  |	mid=7, val=0   	|
     if (guess>7) return  1;                  |                	|
     return 0;                                |	               	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
>>   return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	mid=6, val=-1  	|
   int Test(int guess) {                      |GuessR lo=7,hi=7	|
     if (guess<7) return -1;                  |	return 7       	|
     if (guess>7) return  1;                  |                	|
     return 0;                                |	               	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);<<    |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);      |	mid=8, val=1   	|
     return mid;                              |GuessR lo=6,hi=7	|
   }                                          |	return 7       	|
   int Test(int guess) {                      |                	|
     if (guess<7) return -1;                  |                	|
     if (guess>7) return  1;                  |                	|
     return 0;                                |	               	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | mid=5, val=-1  	|
     if (val<0) return GuessR(mid+1,hi);      |GuessR lo=6,hi=10|
     if (val>0) return GuessR(lo,mid-1);<<    |	return 7       	|
     return mid;                              |                 |
   }                                          |	         	|
   int Test(int guess) {                      |                	|
     if (guess<7) return -1;                  |                	|
     if (guess>7) return  1;                  |                	|
     return 0;                                |	               	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  |GuessR lo=0,hi=10|
     int val = Test(mid);                     | return 7       	|
     if (val<0) return GuessR(mid+1,hi);<<    |                 |
     if (val>0) return GuessR(lo,mid-1);      |	               	|
     return mid;                              |                 |
   }                                          |	         	|
   int Test(int guess) {                      |                	|
     if (guess<7) return -1;                  |                	|
     if (guess>7) return  1;                  |                	|
     return 0;                                |	               	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |main             |
     int mid = (hi-lo)/2+lo;                  | return 7        |
     int val = Test(mid);                     |                	|
     if (val<0) return GuessR(mid+1,hi);      |                 |
     if (val>0) return GuessR(lo,mid-1);      |	               	|
     return mid;                              |                 |
   }                                          |	         	|
   int Test(int guess) {                      |                	|
     if (guess<7) return -1;                  |                	|
     if (guess>7) return  1;                  |                	|
     return 0;                                |	               	|
   }                                          |		       	|
   int main() { return GuessR(0,10);<}        |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {               |                 |
     int mid = (hi-lo)/2+lo;                  |                 |
     int val = Test(mid);                     |                	|
     if (val<0) return GuessR(mid+1,hi);      |                 |
     if (val>0) return GuessR(lo,mid-1);      |	               	|
     return mid;                              |                 |
   }                                          |	         	|
   int Test(int guess) {                      |                	|
     if (guess<7) return -1;                  |                	|
     if (guess>7) return  1;                  |                	|
     return 0;                                |	               	|
   }                                          |		       	|
   int main() { return GuessR(0,10); }        |	       	       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		       	|
					      |		        |
					      |                 |
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {              
     int mid = (hi-lo)/2+lo;                 
     int val = Test(mid);                      	 
     if (val<0) return GuessR(mid+1,hi);	     
     if (val>0) return GuessR(lo,mid-1);	     
     return mid;                        
   }                                    
   int Test(int guess) {                
     if (guess<7) return -1;            
     if (guess>7) return  1;            
     return 0;                          
   }                                    
   int main() { return GuessR(0,10); }  
					
				       	
 - In general, how many calls to Test will we make?	       
      			  				       
 - In general, how many recursive calls to GuessR will we make?
					


					
					
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {              
     int mid = (hi-lo)/2+lo;                 
     int val = Test(mid);                      	 
     if (val<0) return GuessR(mid+1,hi);	     
     if (val>0) return GuessR(lo,mid-1);	     
     return mid;                        
   }                                    
   int Test(int guess) {                
     if (guess<7) return -1;            
     if (guess>7) return  1;            
     return 0;                          
   }                                    
   int main() { return GuessR(0,10); }  
					
				       	
 - In general, how many calls to Test will we make?	       
      			  				       
 - In general, how many recursive calls to GuessR will we make?
					
					
					
					
					
RECURSION: BINARY SEARCH		      
   int GuessR(int lo, int hi) {              
     int mid = (hi-lo)/2+lo;                 
     int val = Test(mid);                      	 
     if (val<0) return GuessR(mid+1,hi);	     
     if (val>0) return GuessR(lo,mid-1);	     
     return mid;                        
   }                                    
   int Test(int guess) {                
     if (guess<7) return -1;            
     if (guess>7) return  1;            
     return 0;                          
   }                                    
   int main() { return GuessR(0,10); }  
					
				       	
 - In general, how many calls to Test will we make?	       
      			  				       
 - In general, how many recursive calls to GuessR will we make?
					
 - How many different numbers can you guess with a given number
   of calls to Test?			
					
					
RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE








RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] 







RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] G(23,23)







RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] G(23,23)        {1}







RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] G(23,23)        {1}
 [2] G(10,12)






RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] G(23,23)        {1}
 [2] G(10,12)
          |  \
          11  G(12,12)




RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] G(23,23)        {1}
 [2] G(10,12)
          |  \
          11  G(12,12)
       	       |
       	      12


RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] G(23,23)        {1}
 [2] G(10,12)
     /    |  \
G(10,10)  11  G(12,12)
       	       |
       	      12


RECURSION: BINARY SEARCH
int GuessR(int lo, int hi) {
  int mid = (hi-lo)/2+lo;
  int val = Test(mid);
  if (val<0) return GuessR(mid+1,hi);
  if (val>0) return GuessR(lo,mid-1);
  return mid;
}
int Guess2() { return GuessR(0,1000000000); }


Fast?  How many calls on 'Test(int)'?
Well, how big a range of numbers can we guess in
 at most 'k' Tests?

  k              RANGE SIZE
 [1] G(23,23)        {1}
 [2] G(10,12)        {3}
     /    |  \
G(10,10)  11  G(12,12)
    |  	       |
   10  	      12


RECURSION: BINARY SEARCH
  k              RANGE SIZE
 [1] G(23,23)        {1}
 [2] G(10,12)        {3}
     /    |  \
G(10,10)  11  G(12,12)
    |  	       |
   10  	      12
















RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}
     /    |  \
G(10,10)  11  G(12,12)
    |  	       |
   10  	      12
















RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |
     /    |  \                 	   G(19,21)  22
G(10,10)  11  G(12,12)
    |  	       |
   10  	      12
















RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |
     /    |  \                 	   G(19,21)  22
G(10,10)  11  G(12,12)	               | \
    |  	       |                      20  G(21,21)
   10  	      12
















RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |
     /    |  \                 	   G(19,21)  22
G(10,10)  11  G(12,12)	               | \
    |  	       |                      20  G(21,21)
   10  	      12                       	     |
       	       	       	         	    21















RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |	 \
     /    |  \                 	   G(19,21)  22	  G(23,25)
G(10,10)  11  G(12,12)	  	   /   | \     	   / |  \
    |  	       |            G(19,19)  20  G(21,21) | 24	 G(25,25)
   10  	      12           	|      	     | 	 G(23,23)    |
       	       	       	       19	    21	    |       25
                         			   23














RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |	 \
     /    |  \                 	   G(19,21)  22	  G(23,25)
G(10,10)  11  G(12,12)	  	   /   | \     	   / |  \
    |  	       |            G(19,19)  20  G(21,21) | 24	 G(25,25)
   10  	      12           	|      	     | 	 G(23,23)    |
       	       	       	       19	    21	    |       25
                         			   23
 [4]                {15} 10:24













RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |	 \
     /    |  \                 	   G(19,21)  22	  G(23,25)
G(10,10)  11  G(12,12)	  	   /   | \     	   / |  \
    |  	       |            G(19,19)  20  G(21,21) | 24	 G(25,25)
   10  	      12           	|      	     | 	 G(23,23)    |
       	       	       	       19	    21	    |       25
                         			   23
 [4]                {15} 10:24
                           |  \------------\
                       	  17   	       	  18:24
                           	     /---/  |
                                   18:20    21
                               	       |\--\
                                       19  20:20
                               	      	     |
                               	    	    20





RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |	 \
     /    |  \                 	   G(19,21)  22	  G(23,25)
G(10,10)  11  G(12,12)	  	   /   | \     	   / |  \
    |  	       |            G(19,19)  20  G(21,21) | 24	 G(25,25)
   10  	      12           	|      	     | 	 G(23,23)    |
       	       	       	       19	    21	    |       25
                         			   23
 [4]                {15} 10:24
             /----------/  |  \------------\
           10:16       	  17   	       	  18:24
    /-----/  | 	\-----\		     /---/  |  \--------\
  10:12      13	     14:16         18:20    21 	       22:24
  /   |	\---\  	     /  | \    	    /  |\--\	      /  |  \
10:10 11   12:12  14:14 15 16:16 18:18 19  20:20 22:22  23  24:24
  |	     | 	    |  	     | 	   |  	     | 	   |          |
 10	     12	   14	    16	  18	    20	  22         24





RECURSION: BINARY SEARCH
  k              RANGE SIZE      k             	       	RANGE SIZE
 [1] G(23,23)        {1}       	[3]    	  G(19,25)          {7}
 [2] G(10,12)        {3}       	 	  /   |	 \
     /    |  \                 	   G(19,21)  22	  G(23,25)
G(10,10)  11  G(12,12)	  	   /   | \     	   / |  \
    |  	       |            G(19,19)  20  G(21,21) | 24	 G(25,25)
   10  	      12           	|      	     | 	 G(23,23)    |
       	       	       	       19	    21	    |       25
                         			   23
 [4]                {15} 10:24
             /----------/  |  \------------\
           10:16       	  17   	       	  18:24
    /-----/  | 	\-----\		     /---/  |  \--------\
  10:12      13	     14:16         18:20    21 	       22:24
  /   |	\---\  	     /  | \    	    /  |\--\	      /  |  \
10:10 11   12:12  14:14 15 16:16 18:18 19  20:20 22:22  23  24:24
  |	     | 	    |  	     | 	   |  	     | 	   |          |
 10	     12	   14	    16	  18	    20	  22         24

In general, with at most 'k' calls on 'Test', we can guess
            k
a range of 2 -1 different numbers.

RECURSION: BINARY SEARCH

In general, with at most 'k' calls on 'Test', we can guess
            k
a range of 2 -1 different numbers.



















RECURSION: BINARY SEARCH

In general, with at most 'k' calls on 'Test', we can guess
            k
a range of 2 -1 different numbers.

	      tests
 So, Range = 2	   - 1

   		tests
  or Range+1 = 2













RECURSION: BINARY SEARCH

In general, with at most 'k' calls on 'Test', we can guess
            k
a range of 2 -1 different numbers.

	      tests
 So, Range = 2	   - 1

   		tests
  or Range+1 = 2
Let's let n = Range+1, so

       	         tests
            n = 2









RECURSION: BINARY SEARCH

In general, with at most 'k' calls on 'Test', we can guess
            k
a range of 2 -1 different numbers.

	      tests
 So, Range = 2	   - 1

   		tests
  or Range+1 = 2
Let's let n = Range+1, so

       	         tests
            n = 2
       	       	      tests
      log (n) = log (2 	  )
         2   	   2

      log (n) = tests
         2



RECURSION: BINARY SEARCH

In general, with at most 'k' calls on 'Test', we can guess
            k
a range of 2 -1 different numbers.

	      tests
 So, Range = 2	   - 1

   		tests
  or Range+1 = 2
Let's let n = Range+1, so

       	         tests
            n = 2
       	       	      tests
      log (n) = log (2 	  )
         2   	   2

      log (n) = tests
         2

So: Work needed to guess among n numbers = O(log (n))
						2
RECURSION: BINARY SEARCH

       	         tests
            n = 2
       	       	      tests
      log (n) = log (2 	  )
         2   	   2

      log (n) = tests
         2

So: Work needed to guess among n numbers = O(log(n))
Is that good?  Better than O(n)?











RECURSION: BINARY SEARCH

       	         tests
            n = 2
       	       	      tests
      log (n) = log (2 	  )
         2   	   2

      log (n) = tests
         2

So: Work needed to guess among n numbers = O(log(n))
Is that good?  Better than O(n)?

      n        	  log(n)
      1	       	    0
     10		    3.3
    100		    6.6
   1000		    9.9
  10000		   13.3		    
 100000		   16.3		    
1000000            19.9		    
       	  ...yeah.. log(n) is good  

